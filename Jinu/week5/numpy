 np.array( [] )    -> 행렬 생성

 np.zeros((a,b))  -> (a,b)의 0행렬 생성

 np.ones((a,b))   -> (a,b)의 1행렬 생성

 np.full((a,b),n)   -> n으로 채워진 (a,b) 행렬 생성

 np.eye(n)         -> n x n의 단위행렬 생성

 np.random.random((a,b))  -> (a,b)의 랜덤 행렬 생성

 np.tile( x, (a,b))   -> 행렬 x를 세로로 a개, 가로로 b개 쌓음 \

 np.reshape(x, (a,b,c))   -> 행렬 x를 (a,b,c)의 행렬의 형태로 바꿈
							이 때, 행렬 x의 요소 개수가 a x b x c의 개수와 같아야함
							Ex) a = [[1,2,3],[1,2,3],[1,2,3],[1,2,3]]     -> 요소 개수 총 12개
							    이는,
							     np.reshape(a, (12,1))        -> [ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
							     np.reshape(a, (2,6))          -> [[ 1, 2, 3, 1, 2, 3 ]
															      [ 1, 2, 3, 1, 2, 3 ]]
							     np.reshape(a, (2,3,2))        ->[[1, 2]
																 [3, 1]
																 [2, 3]]
																
																[[1, 2]
																 [3, 1]
																 [2, 3]]
															
								등으로 변환시킬 수 있다.




  	• 배열
  
  Import numpy as np



 a = np.array([1,2,3])		# [1, 2, 3]

 type(a)				# <type 'numpy.ndarray'>

 a.shape				# (3,)		-> (3,1)인 행렬

 b = np.array([[1, 2, 3], [4 ,5 ,6], [7 ,8 ,9]		#	[1, 2, 3
			                                               4, 5, 6
			                                               7, 8, 9]

 b. shape						# (2,3)		->(2,3)인 행렬




	• 배열 인덱싱


Import numpy as np


 a= np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])			#	[1, 2, 3, 4
                                                                   5, 6, 7, 8
                                                                   9, 10, 11 ,12]
 b = a[:2, 1:3]			#	[2, 3
                      6, 7]
 b[0, 0] = 77				
 				
 print(b)			#	[77, 3
				        6,   7]
 print(a)			#	 [1, 77, 3, 4
				          5,    6, 7, 8
				          9, 10, 11, 12]

=> b의 요소를 바뀌면, a의 요소도 같이 바뀐다.




	• 슬라이싱

Import numpy as np


 a= ([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])			#	[1, 2, 3, 4
				                                                   5, 6, 7, 8
				                                                   9, 10, 11 ,12]
 row_r1 = a[1:2, :]			#	[5 6 7 8]
				 
 col_r1 = a[:, 1:2]				[2
				                   6
				                  10]
                          



	• 정수 배열 인덱싱


Import numpy as np


 a= np.array([[1, 2], [3, 4], [5, 6]])			#	[1, 2
				 3, 4
				 5, 6]
 print( a[0, 1, 2], [0, 1, 0])			#	[1 4 5] 
			=>	[0,1] [1,1] [2,0]을 출력
				 print( a[0,1], a[1,1], a[2,0]) 과 같음

 a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])				
 
 b = np.array([0, 2, 0, 1])
				
 print( a[ np.arrange(4), b] )			#	[1 6 7 11] 
 			->	 a의 [0,0] [1,2] [2,0] [3,1]을 출력
 a[np.arange(4), b] += 10			->	 위의 값에 10씩 증가





	• 배열 type


Import numpy as np


 a = np.array([1.0, 2.0])			#	[1. , 2.]
 a.dtype			#	 'float64'

 a = np.array([1.0, 2.0], dtype = np.int64)			->	배열을 int 64형태로 저장
 a.dtype			#	 'int64'





	• 배열 연산
                          
                          
                          
Import numpy as np


 a = np.array( [[1, 2], [3, 4]])				
 b = np.array( [[5, 6], [7, 8]])				
				
 a + b			#	[ [6.0 8.0
				    10.0 12.0] ]
 np.add(a,b)			#	위와 같은 출력
 				
 a - b			#	[ [-4.0 -4.0
				   -4.0 -4.0 ] ]
 np.substrat(a,b)				
				
 a * b			#	[ [ 5.0 12.0
				   21.0 32.0] ] 
 np.multiply(a,b)			#	 요소별 곱
				
 a / b			#	[ [ 0.2  0.33333
				   0.42857  0.5 ] ]
 np.divide(a,b)			#	 요소별 나눗셈
				
 np.sqrt(a)			#	 요소별 제곱근
				
				
 a.dot(b)			#	 내적 (행렬 곱)
 np.dot(a,b)
				
 np.sum(a)			#	 모든 요소들의 합
 np.sum(a, axis = 0)			#	 각 열에 대한 합 연산 (세로 합)
 np.sum(a, axis = 0)			# 	 각 행에 대한 합 연산 (가로 합)
				
 a.T			#	 transpose



	• 브로드캐스팅


일정 조건을 부합하는 다른 형태의 배열끼리 연산을 수행하는 것을 의미.

아래의 조건을 만족해야함.

1. 두 배열이 동일한 rank를 가지고 있지 않다면, 낮은 rank의 1차원 배열이 높은 rank 배열의 shape로 간주합니다.
2. 특정 차원에서 두 배열이 동일한 크기를 갖거나, 두 배열 중 하나의 크기가 1이라면 그 두 배열은 특정 차원에서 compatible하다고 여겨집니다.
3. 두 행렬이 모든 차원에서 compatible하다면, 브로드캐스팅이 가능합니다.
4. 브로드캐스팅이 이뤄지면, 각 배열 shape의 요소별 최소공배수로 이루어진 shape가 두 배열의 shape로 간주합니다.
5. 차원에 상관없이 크기가 1인 배열과 1보다 큰 배열이 있을 때, 크기가 1인 배열은 자신의 차원 수만큼 복사되어 쌓인 것처럼 간주합니다.



Ex)

X = np.array( [4, 5, 6, 7] ).reshape(4,1)

Y = np.array( [3, 3, 3, 3] )
											

X + Y = 

